#!/bin/bash




##### Define functions #####
#Print the help menu
function print_help_menu() {
    cat <<helpChunk
    
    ###########################################################################
                  This is the help menu for SequelTools version 1.3.2
    ###########################################################################
    Dependencies for this program are samtools, Python, and R.
    For this help menu use the argument -h or no arguments.
    Required arguments: -u, -t

    Notes: *A CLR is a Continuous Long Read
           *A subedCLR is a CLR containing at least one subread

    General arguments:
        -u : A file listing the names of subreads .bam sequence files
        -c : A file listing the names of scraps .bam sequence files
        -t : Declares which of SequelTools' tools will be used.  Options: 
             'Q' for quality control, 
	     'S' for subsampling by longest subreads (per CLR) and/or by random 
	     CLR selection.
	     'F' for filtering reads by CLR minimum length and/or having at least 
	         one complete pass of the DNA molecule past the polymerase and/or 
	         normal adapters for scraps. Scraps files are required for this
                 tool.
	     No default is provided.
        -n : The number of threads to use for extracting information from .bam 
             files for each .bam file. Default is '1'
        -o : Folder to output results to. Default is 'SequelToolsResults'
        -v : A verbose option for those who want updates as the program progresses
        -h : Opens this help menu

        Quality Control tool arguments:
        -k : For the quality control tool, keep intermediate files (these are 
             removed by default)
        -g : For the quality control tool, groups desired (only works when scraps 
             files are included). Options: 'a' for all (CLRs, subedCLRs, subreads, 
             and longest subreads), and 'b' for basic (subedCLRs and subreads).  
             Default is 'a'
        -p : For the quality control tool, plots desired.  Options: 'b' for basic 
             (N50 barplot, summary data table, and total bases barplot), 'i' for 
             intermediate (N50 barplot, summary data table, total bases barplot, 
             ZOR plot, PSR plot, boxplot of subread read lengths with N50, boxplot 
             of subedCLR read lengths with N50), and 'a' for all (N50 barplot, L50 
             barplot, summary data table, read length histograms, total bases 
             barplot, ZOR plot, PSR plot, Boxplot of subread read lengths with N50, 
             boxplot of subedCLR read lengths with N50, subreads/CLR frequency 
             plot, and adapters/CLR frequency plot).  Default is 'i'. The boxplot 
             of subedCLR read lengths with N50, subreads/CLR frequency plot, and 
             adapters/CLR frequency plot are only produced if scraps files are 
             included.
        -r : For the quality control tool, an R script the user has chosen to use 
             instead of the provided R script for plotting.  Keep in mind that 
             SequelTools uses separate R scripts for running with and without 
             scraps files.
        -s : For the quality control tool, skips samtools and Python steps for the 
             purpose of testing an alternative R script.  This argument is only 
             appropriate after having run SequelTools with the -k argument 
             sucussfully in the same folder such that the intermediate files 
             generated by samtools and Python have already been generated and have 
             not been deleted at the end of SequelTools' operation.

    Read Subsampling & Read Filtering tools arguments
         -f : For the read subsampling and read filtering tools, this option allows 
             the user to choose the format of the results files.  Options: 's' for 
             SAM, 'b' for BAM, and '2' for both.  Default is 's' simply because the 
             subsetting longest subreads tool runs faster with this option. 

    Read Subsampling tool arguments
         -T : For the read subsampling tool, choose one or more of the subsampling
             options: 'l' for longest subreads and 'r' for random CLR subsampling.
             No default is provided.
         -R : For the read subsampling tool, when using the random CLR subsampling
             option, this argument specifies the proportion of CLRs retained from 0 
             to 1, where 0 means all CLRs are discarded and 1 means all CLRs are 
	     retained.  Default is 0.1.

    Read Filtering tool arguments
        -C : For the read filtering tool, filter by CLR minimum length. No 
             default is provided.
        -P : For the read filtering tool, filter by number of complete passes of 
             the DNA template. No default is provided.
        -N : For the read filtering tool, filter by normal scraps adapters defined 
             as having a ZMW classification annotation of 'N' for 'normal' and a 
             scrap region-type annotation of 'A' for 'adapter'. No default is 
             provided.
        -Z : For the read filtering tool, when filtering by CLR minimum length, the
             minimum length threshold for retaining each CLR. No default is 
             provided.

helpChunk
    exit 1
}

#Set an array of files and line numbers to pass to R .  Arg 1=ARGS_FOR_R Arg 2 is I
function make_args_for_R_array() {
    if [ "$NOSCRAPS" == true ]; then
        FILES_FOR_R+="$BASE.SMRTcellStats_noScraps.txt,"
        FILES_FOR_R+="$BASE.readLens.sub.txt,"
        FILES_FOR_R+="$BASE.readLens.longSub.txt,"
        LENGTHS_FOR_R+="$(wc -l "$BASE.SMRTcellStats_noScraps.txt" | awk '{print $1}'),"
        LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.sub.txt" | awk '{print $1}'),"
        LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.longSub.txt" | awk '{print $1}'),"
    else
        if [ "$GROUPS_DESIRED" == "a" ]; then
            FILES_FOR_R+="$BASE.SMRTcellStats_wScrapsA.txt,"
            FILES_FOR_R+="$BASE.readLens.sub.txt,"
            FILES_FOR_R+="$BASE.readLens.clr.txt,"
            FILES_FOR_R+="$BASE.readLens.subedClr.txt,"
            FILES_FOR_R+="$BASE.readLens.longSub.txt,"
            FILES_FOR_R+="$BASE.clrStats.txt,"
            LENGTHS_FOR_R+="$(wc -l "$BASE.SMRTcellStats_wScrapsA.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.sub.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.clr.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.subedClr.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.longSub.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.clrStats.txt" | awk '{print $1}'),"

        elif [ "$GROUPS_DESIRED" == "b"   ]; then
            FILES_FOR_R+="$BASE.SMRTcellStats_wScrapsB.txt,"
            FILES_FOR_R+="$BASE.readLens.sub.txt,"
            FILES_FOR_R+="$BASE.readLens.subedClr.txt,"
            FILES_FOR_R+="$BASE.readLens.longSub.txt,"
            FILES_FOR_R+="$BASE.clrStats.txt,"
            LENGTHS_FOR_R+="$(wc -l "$BASE.SMRTcellStats_wScrapsB.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.sub.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.subedClr.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.readLens.longSub.txt" | awk '{print $1}'),"
            LENGTHS_FOR_R+="$(wc -l "$BASE.clrStats.txt" | awk '{print $1}'),"
        fi
    fi
}



##### BODY #####
#If no arguments are given, print help menu and exit
if [ $# -eq 0 ]; then
    print_help_menu
fi


#Check that the user has Python and determine Python version 
command -v python >/dev/null 2>&1 || {
    echo -e >&2 "\nERROR: This program requires Python to run."
    echo >&2 "You do not seem to have Python."
    print_help_menu
}

PY_VER=$(python -c 'import sys; print("%d" % (sys.version_info[0]))')


#Check that the user has samtools
command -v samtools >/dev/null 2>&1 || {
    echo -e >&2 "\nERROR: This program requires samtools to run."
    echo >&2 "You do not seem to have samtools."
    print_help_menu
}


#Assign defaults to variables
SUBREADS_FILES_BAM=""
SCRAPS_FILES_BAM=""
NTHREADS=1
VERBOSE=false
KEEP=false
REQUIRED_PAR=0 #used to determine whether all required parameters were used
GROUPS_DESIRED='a'
PLOTS_DESIRED='i'
OUT_FOLD='SequelToolsResults'
NOSCRAPS=true #whether to run in NOSCRAPS mode or not
ALTRSCRIPT=""
TOSKIP=false
TOOL=""
FORMAT="s"
ARGSUSED=""
SUBSAMP_LONGSUB=false
SUBSAMP_RAND=false
RANDCLR_PROP=0.1
CLR_FILT=false
NUMPASS_FILT=false
NORMSCRAP_FILT=false
CLR_FILT_THRESH=0

#Go through input and assign input arguments to variables
while getopts ":t:c:o:n:g:p:r:u:f:T:R:Z:CPNvksh" opt; do
    case ${opt} in 
      u )
        SUBREADS_FILES_BAM=$OPTARG
        (( REQUIRED_PAR++ ))
        ARGSUSED="${ARGSUSED}u"
        ;;
      c )
        SCRAPS_FILES_BAM=$OPTARG
        NOSCRAPS=false
        ARGSUSED="${ARGSUSED}c"
        ;;
      o )
        OUT_FOLD=$OPTARG
        ARGSUSED="${ARGSUSED}o"
        ;;
      n )
        NTHREADS=$OPTARG
        ARGSUSED="${ARGSUSED}n"
        ;;
      g )
        if [ "$OPTARG" == "a" ] || [ "$OPTARG" == "b" ]; then
            GROUPS_DESIRED=$OPTARG
        else
            echo -e "\nERROR: Invalid groups desired option: -g $OPTARG" 1>&2
            print_help_menu
        fi
        ARGSUSED="${ARGSUSED}g"
        ;;
      p )
        if [ "$OPTARG" == "b" ] || [ "$OPTARG" == "i" ] || [ "$OPTARG" == "a" ]; then
            PLOTS_DESIRED=$OPTARG
        else
            echo -e "\nERROR: Invalid plots desired option: -p $OPTARG" 1>&2
            print_help_menu
        fi
        ARGSUSED="${ARGSUSED}p"
        ;;
      t ) 
        if [ "$OPTARG" == "Q" ] || [ "$OPTARG" == "S" ] || [ "$OPTARG" == "F"  ]; then
            TOOL=$OPTARG
            (( REQUIRED_PAR++ ))
        else
            echo -e "\nERROR: Invalid tool option: -t $OPTARG" 1>&2
            print_help_menu
        fi
        ARGSUSED="${ARGSUSED}t"
        ;;
      v )
        VERBOSE=true
        ARGSUSED="${ARGSUSED}v"
        ;;      
      k )
        KEEP=true
        ARGSUSED="${ARGSUSED}k"
        ;;
      s )
        TOSKIP=true
        ARGSUSED="${ARGSUSED}s"
        ;;
      r )
        if [ "$OPTARG" != "" ]; then
            ALTRSCRIPT=$OPTARG
        else
            echo -e "\nERROR: An alternative R script file name must be provided with the 'r' argument" 1>&2
            print_help_menu
        fi
        ARGSUSED="${ARGSUSED}r"
        ;;
      f )
        if [ "$OPTARG" == "s" ] || [ "$OPTARG" == "b" ] || [ "$OPTARG" == "2"  ]; then
            FORMAT=$OPTARG
        else
            echo -e "\nERROR: Invalid format option: -f $OPTARG" 1>&2
            print_help_menu
        fi
        ARGSUSED="${ARGSUSED}f"
        ;;
      T ) 
	if [ "$OPTARG" == "l" ] || [ "$OPTARG" == "r" ] || [ "$OPTARG" == "lr" ] || [ "$OPTARG" == "rl" ]; then
            if [ "$OPTARG" == "l" ] || [ "$OPTARG" == "lr" ] || [ "$OPTARG" == "rl" ]; then
	        SUBSAMP_LONGSUB=true
	    fi
	    if [ "$OPTARG" == "r" ] || [ "$OPTARG" == "lr" ] || [ "$OPTARG" == "rl" ]; then
                SUBSAMP_RAND=true
            fi 
        else
            echo -e "\nERROR: Invalid subsampling option: -T $OPTARG" 1>&2
            print_help_menu
        fi
        ARGSUSED="${ARGSUSED}T"
	;;
      R )
        if [[ $(bc <<< "$OPTARG >= 0 && $OPTARG <= 1") == 1 ]]; then
            RANDCLR_PROP=$OPTARG
        else
            echo -e "\nERROR: Invalid read subsampling proportion -R $OPTARG" 1>&2
            print_help_menu
        fi
	ARGSUSED="${ARGSUSED}R"
	;;
      C )
        CLR_FILT=true
        ARGSUSED="${ARGSUSED}C"
	;;
      P )
        NUMPASS_FILT=true
        ARGSUSED="${ARGSUSED}P"
	;;
      N )
        NORMSCRAP_FILT=true
        ARGSUSED="${ARGSUSED}N"
	;;
      Z )
	if [[ $OPTARG =~ ^[0-9]+$ ]]; then
            CLR_FILT_THRESH=$OPTARG
	else
	    echo -e "\nERROR: Invalid CLR length filtering threshold option: -Z $OPTARG" 1>&2
            print_help_menu
	fi
	ARGSUSED="${ARGSUSED}Z"
        ;;
      h )
        print_help_menu
        ARGSUSED="${ARGSUSED}h"
        ;;
      \? )
        echo -e "\nERROR: Invalid argument: -$OPTARG" 1>&2
        print_help_menu
        ;;
      : )
        echo -e "\nERROR: No arguments provided" 1>&2
        print_help_menu
        ;;
    esac
done


#If required arguments are not provided throw an error and provide the help page
if (( REQUIRED_PAR != 2 )); then
    echo -e "\nERROR: The required parameters for this program are -u. and -t"
    echo "You are lacking these parameters.  See our help page below"
    print_help_menu
fi

#Check that arguments match the chosen tool
if [ "$TOOL" == "Q" ]; then
    TOEXIT=false
    FIN="$(echo $ARGSUSED | grep -c 'f')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-f' argument is not appropriate for the quality control tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'T')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-T' argument is not appropriate for the quality control tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'R')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-R' argument is not appropriate for the quality control tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'C')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-C' argument is not appropriate for the quality control tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'P')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-P' argument is not appropriate for the quality control tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'N')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-N' argument is not appropriate for the quality control tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'Z')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-Z' argument is not appropriate for the quality control tool" 1>&2
        TOEXIT=true
    fi

    if [ $TOEXIT == true ]; then
        exit 1
    fi


elif [ "$TOOL" == "S" ]; then 
    TOEXIT=false
    FIN="$(echo $ARGSUSED | grep -c 'k')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-k' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'g')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-g' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'p')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-p' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'r')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-r' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 's')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-s' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'T')"
    if [ "$FIN" == 0 ]; then
        echo -e "\nThe '-T' argument is required for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'C')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-C' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'P')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-P' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'N')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-N' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'Z')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-Z' argument is not appropriate for the read subsampling tool" 1>&2
        TOEXIT=true
    fi

    if [ $TOEXIT == true ]; then
        exit 1
    fi

elif [ "$TOOL" == "F" ]; then
    TOEXIT=false
    FIN="$(echo $ARGSUSED | grep -c 'c')"
    if [ "$FIN" == 0 ]; then
        echo -e "\nThe '-c' argument is required for the read filtering tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'k')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-k' argument is not appropriate for the read filtering tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'g')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-g' argument is not appropriate for the read filtering tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'p')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-p' argument is not appropriate for the read filtering tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'r')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-r' argument is not appropriate for the read filtering tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 's')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-s' argument is not appropriate for the read filtering tool" 1>&2
        TOEXIT=true
    fi
    FIN="$(echo $ARGSUSED | grep -c 'T')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-T' argument is not appropriate for the read filtering tool" 1>&2
        TOEXIT=true
    fi    
    FIN="$(echo $ARGSUSED | grep -c 'R')"
    if [ "$FIN" != 0 ]; then
        echo -e "\nThe '-s' argument is not appropriate for the read filtering tool" 1>&2
        TOEXIT=true
    fi
    FINC="$(echo $ARGSUSED | grep -c 'C')"
    if [ "$FINC" != 0 ]; then
        FIN="$(echo $ARGSUSED | grep -c 'Z')" #If -C is used -Z must also be used
        if [ "$FIN" == 0 ]; then
            echo -e "\nThe '-Z' argument must be used with the '-C' argument" 1>&2
            TOEXIT=true
        fi
    fi

    #-C, -P, and/or -N must be used with the read filtering tool
    FINP="$(echo $ARGSUSED | grep -c 'P')"
    FINN="$(echo $ARGSUSED | grep -c 'N')"
    if [ "$FINC" == 0 ] && [ "$FINP" == 0 ] && [ "$FINN" == 0 ]; then
        echo -e "\nYou must choose filtering criteria for the read filtering tool." 1>&2
	echo -e "Try using either -C, -P, and/or -N parameters." 1>&2
	print_help_menu
    fi

    if [ $TOEXIT == true ]; then
        exit 1
    fi
fi    


#Create the output folder
if [ ! -d "$OUT_FOLD" ]; then
    mkdir "$OUT_FOLD"
fi


#Quality control tool
if [ "$TOOL" == "Q" ]; then
    echo "Beginning quality control function" 

    #Check that user has R
    command -v Rscript >/dev/null 2>&1 || {
        echo -e >&2 "\nERROR: This program requires Rscript to run."
        echo >&2 "You do not seem to have Rscript."
        print_help_menu
    }

    #Declare whether running with or without scraps
    if [ $NOSCRAPS == true ]; then
        echo -e "\nRunning in NO_SCRAPS mode"
    else
        echo -e "\nRunning in WITH_SCRAPS mode"
    fi

    #Declare if an alternative R script has been provided
    if [ "$ALTRSCRIPT" != "" ]; then
        echo -e "\nUsing an alternative R script for plotting"
    fi


    #Go through scraps and subreads filename files and capture .bam filenames
    SUBREADS_FILES_ARRAY_BAM=()
    I=1
    while read -r line; do
        SUBREADS_FILES_ARRAY_BAM[ $I ]="$line"
        (( I++ ))
    done < "$SUBREADS_FILES_BAM"

    if [ $NOSCRAPS == false ]; then
        SCRAPS_FILES_ARRAY_BAM=()
        I=1
        while read -r line; do
            SCRAPS_FILES_ARRAY_BAM[ $I ]="$line"
            (( I++ ))
        done < "$SCRAPS_FILES_BAM"
    fi


    #Go through BAM arrays and make arrays without the .bam at the end
    SUBREADS_FILES_ARRAY_NOBAM=()
    I=1
    for BAM in "${SUBREADS_FILES_ARRAY_BAM[@]}"; do
        if [[ "$BAM" =~ (.*).bam ]]; then
            NOBAM=${BASH_REMATCH[1]}
            SUBREADS_FILES_ARRAY_NOBAM[ $I ]="$NOBAM"
        fi
        (( I++ ))     
    done

    if [ $NOSCRAPS == false ]; then
        SCRAPS_FILES_ARRAY_NOBAM=()
        I=1
        for BAM in "${SCRAPS_FILES_ARRAY_BAM[@]}"; do
            if [[ "$BAM" =~ (.*).bam ]]; then
                NOBAM=${BASH_REMATCH[1]}
                SCRAPS_FILES_ARRAY_NOBAM[ $I ]="$NOBAM"
            fi
            (( I++ ))
        done
    fi


    #Make an array of base filenames (before .scraps or .subreads)
    FILES_BASE_ARRAY=()
    I=1
    for NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
        if [[ "$NOBAM" =~ (.*).subreads ]]; then
            BASE=${BASH_REMATCH[1]}
            FILES_BASE_ARRAY[ $I ]="$BASE"
        fi
        (( I++ ))
    done

    if [ $NOSCRAPS == false ]; then
        FILES_BASE_ARRAY2=()
        I=1
        for NOBAM in "${SCRAPS_FILES_ARRAY_NOBAM[@]}"; do
            if [[ "$NOBAM" =~ (.*).scraps ]]; then
                BASE=${BASH_REMATCH[1]}
                FILES_BASE_ARRAY2[ $I ]="$BASE"
            fi
            (( I++ ))
        done
    fi


    #Ensure that the scraps and subreads files match
    if [ $NOSCRAPS == false ]; then
        if [ "${FILES_BASE_ARRAY[*]}" != "${FILES_BASE_ARRAY2[*]}" ]; then
            echo -e "\nERROR: Your scraps and subreads files do not match"
            print_help_menu
        fi
    fi

    if [ $TOSKIP == false ]; then
        #Extract names that will contain coords necessary for calculating length
        FAILED_EXTRACTION="ERROR: BAM data extraction failed!"
        if [ $VERBOSE == true ]; then
            echo "Extracting data from .bam files"
        fi

        I=1
        for BAM in "${SUBREADS_FILES_ARRAY_BAM[@]}"; do
            #Check that .bam files exist and are not empty
            if [ ! -s "$BAM" ]; then
                echo >&2 "the BAM file "$BAM" is empty or does not exist"
                print_help_menu
            fi

            NOBAM=${SUBREADS_FILES_ARRAY_NOBAM[I]}
            samtools view --threads "$NTHREADS" -O SAM "$BAM" | awk '{print $1}' > "$NOBAM.seqNames" || {
            echo >&2 "$FAILED_EXTRACTION"
            exit 1
            }
            (( I++ ))
        done

        if [ $NOSCRAPS == false ]; then
            I=1
            for BAM in "${SCRAPS_FILES_ARRAY_BAM[@]}"; do
                #Check that .bam files exist and are not empty
                if [ ! -s "$BAM" ]; then
                    echo >&2 "the BAM file "$BAM" is empty or does not exist"
                    print_help_menu
                fi

                NOBAM=${SCRAPS_FILES_ARRAY_NOBAM[I]}
                samtools view --threads "$NTHREADS" -O SAM "$BAM" | awk '{print $1,"\t",$21,"\t",$22}' > "$NOBAM.seqNamesPlus" || {
                echo >&2 "$FAILED_EXTRACTION"
                exit 1
                }
                (( I++ ))
            done
        fi

        if [ $VERBOSE == true ]; then
            echo "Data extraction was sucessful"
            echo "Beginning calculation of read length statistics"
        fi
    else
        #skip BAM step and tell the user
        if [ $VERBOSE == true ]; then
            echo "Skipping read length calculation (samtools) step"
        fi
    fi

    #If requested, skip Python step and tell the user
    if [ $TOSKIP == true ]; then
        if [ $VERBOSE == true ]; then
            echo "Skipping statiscical calculations (Python) step"
        fi
    fi

    #Calculate read length stats (sum, mean, median, N50, L50)
    FAILED_RLSTATS="ERROR: Calculation of read length statistics failed!"
    FILES_FOR_R=""
    LENGTHS_FOR_R=""
    I=1
    for SUBREADS_NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
        SCRAPS_NOBAM=${SCRAPS_FILES_ARRAY_NOBAM[I]}
        BASE=${FILES_BASE_ARRAY[I]}
 
        if [ $TOSKIP == false ]; then
            if [ $NOSCRAPS == true ]; then
                generateReadLenStats_noScraps.py "$SUBREADS_NOBAM.seqNames" "$BASE.SMRTcellStats_noScraps.txt" "$BASE.readLens.sub.txt" "$BASE.readLens.longSub.txt" || {
                echo >&2 "$FAILED_RLSTATS"
                exit 1
                }
            else
                if [ "$GROUPS_DESIRED" == "a" ]; then
                    generateReadLenStats_wScraps.py "$SCRAPS_NOBAM.seqNamesPlus" "$SUBREADS_NOBAM.seqNames" "$BASE.SMRTcellStats_wScrapsA.txt" "$BASE.readLens.sub.txt" "$BASE.readLens.clr.txt" "$BASE.readLens.subedClr.txt" "$BASE.readLens.longSub.txt" "$BASE.clrStats.txt" "$GROUPS_DESIRED" || {
                    echo >&2 "$FAILED_RLSTATS"
                    exit 1
                    }
                elif [ "$GROUPS_DESIRED" == "b" ]; then
                    generateReadLenStats_wScraps.py "$SCRAPS_NOBAM.seqNamesPlus" "$SUBREADS_NOBAM.seqNames" "$BASE.SMRTcellStats_wScrapsB.txt" "$BASE.readLens.sub.txt" "$BASE.readLens.clr.txt" "$BASE.readLens.subedClr.txt" "$BASE.readLens.longSub.txt" "$BASE.clrStats.txt" "$GROUPS_DESIRED" || {
                    echo >&2 "$FAILED_RLSTATS"
                    exit 1
                    }
                fi
            fi
        fi

        #Set an array of args (files and line numbers) to pass to R.
        make_args_for_R_array

        (( I++ ))
    done

    #Make plots related to read length stats in R
    if [ $VERBOSE == true ]; then
        echo "Read length statistic calculations complete"
        echo "Creating plots"
    fi

    if [ "$ALTRSCRIPT" == "" ]; then
        if [ $NOSCRAPS == false ]; then
            plotForSequelQC_wScraps.R ${FILES_FOR_R::$((${#FILES_FOR_R} - 1))} ${LENGTHS_FOR_R::$((${#LENGTHS_FOR_R} - 1))} "$GROUPS_DESIRED" "$PLOTS_DESIRED" "$VERBOSE" "$OUT_FOLD" #the '::-1' is to remove the comma at the end
        else
            plotForSequelQC_noScraps.R ${FILES_FOR_R::$((${#FILES_FOR_R} - 1))} ${LENGTHS_FOR_R::$((${#LENGTHS_FOR_R} - 1))} "$PLOTS_DESIRED" "$VERBOSE" "$OUT_FOLD" #the '$((${#LENGTHS_FOR_R} - 1))' is to remove the comma at the end
        fi
    else
        if [ $NOSCRAPS == false ]; then
            "$ALTRSCRIPT" ${FILES_FOR_R::$((${#FILES_FOR_R} - 1))} ${LENGTHS_FOR_R::$((${#LENGTHS_FOR_R} - 1))} "$GROUPS_DESIRED" "$PLOTS_DESIRED" "$VERBOSE" "$OUT_FOLD" #the '::-1' is to remove the comma at the end
        else
            "$ALTRSCRIPT" ${FILES_FOR_R::$((${#FILES_FOR_R} - 1))} ${LENGTHS_FOR_R::$((${#LENGTHS_FOR_R} - 1))} "$PLOTS_DESIRED" "$VERBOSE" "$OUT_FOLD" #the '::-1' is to remove the comma at the end
        fi
    fi


    if [ $VERBOSE == true ]; then
        echo "Plot creation complete"
    fi


    #Cleanup intermediate files
    if [ $KEEP == false ]; then
        if [ $VERBOSE == true ]; then
            echo "Deleting intermediate files"
        fi
        I=1
        for SUBREADS_NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
            if [ $NOSCRAPS == false ]; then
                SCRAPS_NOBAM=${SCRAPS_FILES_ARRAY_NOBAM[I]}
            fi
            BASE=${FILES_BASE_ARRAY[I]} 

            rm "$SUBREADS_NOBAM.seqNames"
            rm "$BASE.readLens.sub.txt"
            rm "$BASE.readLens.longSub.txt"
            rm "$BASE.SMRTcellStats_noScraps.txt"

            if [ $NOSCRAPS == false ]; then
                rm "$SCRAPS_NOBAM.seqNamesPlus"
                rm "$BASE.readLens.clr.txt"
                rm "$BASE.readLens.subedClr.txt"
                rm "$BASE.clrStats.txt"
                if [ "$GROUPS_DESIRED" == "a" ]; then
                    rm "$BASE.SMRTcellStats_wScrapsA.txt"
                elif [ "$GROUPS_DESIRED" == "b" ]; then
                    rm "$BASE.SMRTcellStats_wScrapsB.txt"
                fi
            fi

            (( I++ ))
        done
    fi


#Subsetting longest subreads tool
elif [ $TOOL == "S" ]; then
    echo -e "\nBeginning read subsampling function by chosen criteria:"
    if [ $SUBSAMP_LONGSUB == true ] && [ $SUBSAMP_RAND == true ]; then
        echo "  longest subreads and random subsampling"
    elif [ $SUBSAMP_LONGSUB == true ] && [ $SUBSAMP_RAND == false ]; then
        echo "  longest subreads"
    else  #If both are false an error should have already occured
        echo "  random subsampling"
    fi

    #Declare whether running with or without scraps
    if [ $NOSCRAPS == true ]; then
        echo -e "Running in NO_SCRAPS mode"
    else
        echo -e "Running in WITH_SCRAPS mode"
    fi


    #Go through subreads filename files and capture .bam filenames
    SUBREADS_FILES_ARRAY_BAM=()
    I=1
    while read -r line; do
        SUBREADS_FILES_ARRAY_BAM[ $I ]="$line"
        (( I++ ))
    done < "$SUBREADS_FILES_BAM"

    if [ $NOSCRAPS == false ]; then
        SCRAPS_FILES_ARRAY_BAM=()
        I=1
        while read -r line; do
            SCRAPS_FILES_ARRAY_BAM[ $I ]="$line"
            (( I++ ))
        done < "$SCRAPS_FILES_BAM"
    fi


    #Go through BAM arrays and make arrays without the .bam at the end
    SUBREADS_FILES_ARRAY_NOBAM=()
    I=1
    for BAM in "${SUBREADS_FILES_ARRAY_BAM[@]}"; do
        if [[ "$BAM" =~ (.*).bam ]]; then
            NOBAM=${BASH_REMATCH[1]}
            SUBREADS_FILES_ARRAY_NOBAM[ $I ]="$NOBAM"
        fi
        (( I++ ))
    done

    if [ $NOSCRAPS == false ]; then
        SCRAPS_FILES_ARRAY_NOBAM=()
        I=1
        for BAM in "${SCRAPS_FILES_ARRAY_BAM[@]}"; do
            if [[ "$BAM" =~ (.*).bam ]]; then
                NOBAM=${BASH_REMATCH[1]}
                SCRAPS_FILES_ARRAY_NOBAM[ $I ]="$NOBAM"
            fi
            (( I++ ))
        done
    fi


    #Make an array of base filenames (before .scraps or .subreads)
    FILES_BASE_ARRAY=()
    I=1
    for NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
        if [[ "$NOBAM" =~ (.*).subreads ]]; then
            BASE=${BASH_REMATCH[1]}
            FILES_BASE_ARRAY[ $I ]="$BASE"
        fi
        (( I++ ))
    done

    if [ $NOSCRAPS == false ]; then
        FILES_BASE_ARRAY2=()
        I=1
        for NOBAM in "${SCRAPS_FILES_ARRAY_NOBAM[@]}"; do
            if [[ "$NOBAM" =~ (.*).scraps ]]; then
                BASE=${BASH_REMATCH[1]}
                FILES_BASE_ARRAY2[ $I ]="$BASE"
            fi
            (( I++ ))
        done
    fi


    #Ensure that the scraps and subreads files match
    if [ $NOSCRAPS == false ]; then
        if [ "${FILES_BASE_ARRAY[*]}" != "${FILES_BASE_ARRAY2[*]}" ]; then
            echo -e "\nERROR: Your scraps and subreads files do not match"
            print_help_menu
        fi
    fi


    #Convert BAM files to SAM files
    FAILED_EXTRACTION="ERROR: BAM to SAM data conversion failed!"
    if [ $VERBOSE == true ]; then
        echo "Beginning to convert data from BAM to SAM format"
    fi

    I=1
    for BAM in "${SUBREADS_FILES_ARRAY_BAM[@]}"; do
        #Check that .bam files exist and are not empty
        if [ ! -s "$BAM" ]; then
            echo >&2 "the BAM file "$BAM" is empty or does not exist"
            print_help_menu
        fi

        #Convert BAM files to SAM format
        NOBAM=${SUBREADS_FILES_ARRAY_NOBAM[I]}
        samtools view --threads "$NTHREADS" -O SAM -h "$BAM" > "$NOBAM.sam" || {
        echo >&2 "$FAILED_EXTRACTION"
        exit 1
        }

	if [ $NOSCRAPS == false ]; then
	    NOBAM=${SCRAPS_FILES_ARRAY_NOBAM[I]}
            samtools view --threads "$NTHREADS" -O SAM -h "$NOBAM.bam" > "$NOBAM.sam" || {
            echo >&2 "$FAILED_EXTRACTION"
            exit 1
            }
        fi

	(( I++ ))
    done

    if [ $VERBOSE == true ]; then
        echo "BAM to SAM data conversion was sucessful!"
        echo "Beginning to subsample reads by chosen criteria"
    fi

    #Use SAM files to subsample reads by chosen criteria
    I=1
    for SUBREADS_NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
	SCRAPS_NOBAM=${SCRAPS_FILES_ARRAY_NOBAM[I]}
        if [ $NOSCRAPS == true  ]; then
            python subsampleReads_noScraps.py "$SUBREADS_NOBAM.sam" "$OUT_FOLD" "$SUBSAMP_LONGSUB" "$SUBSAMP_RAND" "$RANDCLR_PROP" || {
            echo >&2 "ERROR: Read subsampling failed!"
            exit 1
            }

	else
            python subsampleReads_wScraps.py "$SUBREADS_NOBAM.sam" "$SCRAPS_NOBAM.sam" "$OUT_FOLD" "$SUBSAMP_LONGSUB" "$SUBSAMP_RAND" "$RANDCLR_PROP" || {
            echo >&2 "ERROR: Read subsampling failed!"
            exit 1
            }
	fi

        (( I++ ))
    done

    if [ $VERBOSE == true ]; then
        echo "Read subsampling is complete!"
    fi

    if [ $FORMAT == 'b' ] || [ $FORMAT == "2"  ]; then
        #If the user has requested it, convert the subsampled files to BAM format
        if [ $VERBOSE == true ]; then
            echo "Beginning to convert subsampled data files to BAM format"
        fi

        I=1
        for NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
            if [[ "$NOBAM" =~ (.*).subreads ]]; then
                BASE=${BASH_REMATCH[1]}
                FILES_BASE_ARRAY[ $I ]="$BASE"
            fi

            #Convert BAM files to SAM format
            samtools view --threads "$NTHREADS" -O BAM -h "$OUT_FOLD/$BASE.subSampledSubs.sam" > "$OUT_FOLD/$BASE.subSampledSubs.bam" || {
            echo >&2 "ERROR: SAM to BAM conversion of subsampled subreads files failed!"
            exit 1
            }

	    if [ $NOSCRAPS == false ]; then
                samtools view --threads "$NTHREADS" -O BAM -h "$OUT_FOLD/$BASE.subSampledScraps.sam" > "$OUT_FOLD/$BASE.subSampledScraps.bam" || {
                echo >&2 "ERROR: SAM to BAM conversion of subsampled scraps files failed!"
                exit 1
                }    
	    fi


            if [ $FORMAT != "2" ]; then
		if [ $VERBOSE == true ]; then
                    echo "Beginning to delete SAM format subsampled subreads files"
	        fi
                rm "$OUT_FOLD/$BASE.subSampledSubs.sam" || {
                echo >&2 "ERROR: SAM format subsampled subreads file deletion failed!"
                exit 1
                }

		if [ $NOSCRAPS == false ]; then
		    if [ $VERBOSE == true ]; then
                        echo "Beginning to delete SAM format subsampled scraps files"
	            fi
                    rm "$OUT_FOLD/$BASE.subSampledScraps.sam" || {
                    echo >&2 "ERROR: SAM format subsampled scraps file deletion failed!"
                    exit 1
                    }
	        fi
            fi

            (( I++ ))
        done

        if [ $VERBOSE == true ]; then
            echo "SAM to BAM conversion of subsampled read data files is complete!"
        fi
    fi


elif [ "$TOOL" == "F" ]; then
    echo -e "\nBeginning to filter reads by chosen criteria:"
    if [ $CLR_FILT == true ] && [ $NUMPASS_FILT == true ] && [ $NORMSCRAP_FILT == true ]; then
        echo "  CLR length, number of full passes, and normal scraps"
    elif [ $CLR_FILT == true ] && [ $NUMPASS_FILT == true ] && [ $NORMSCRAP_FILT == false ]; then
        echo "  CLR length and number of full passes"
    elif [ $CLR_FILT == true ] && [ $NUMPASS_FILT == false ] && [ $NORMSCRAP_FILT == true ]; then
        echo "  CLR length and normal scraps"
    elif [ $CLR_FILT == false ] && [ $NUMPASS_FILT == true ] && [ $NORMSCRAP_FILT == true ]; then
        echo "  number of full passes and normal scraps"
    elif [ $CLR_FILT == true ] && [ $NUMPASS_FILT == false ] && [ $NORMSCRAP_FILT == false ]; then
        echo "  CLR length"
    elif [ $CLR_FILT == false ] && [ $NUMPASS_FILT == true ] && [ $NORMSCRAP_FILT == false ]; then
        echo "  number of full passes"
    elif [ $CLR_FILT == false ] && [ $NUMPASS_FILT == false ] && [ $NORMSCRAP_FILT == true ]; then
        echo "  normal scraps"
    else  #If both are false an error should have already occured
        echo "  ERROR: chosen read filtering criteria problem"
	exit 1
    fi
    

    #Go through scraps and subreads filename files and capture .bam filenames
    SUBREADS_FILES_ARRAY_BAM=()
    I=1
    while read -r line; do
        SUBREADS_FILES_ARRAY_BAM[ $I ]="$line"
        (( I++ ))
    done < "$SUBREADS_FILES_BAM"

    SCRAPS_FILES_ARRAY_BAM=()
    I=1
    while read -r line; do
        SCRAPS_FILES_ARRAY_BAM[ $I ]="$line"
        (( I++ ))
    done < "$SCRAPS_FILES_BAM"


    #Go through BAM arrays and make arrays without the .bam at the end
    SUBREADS_FILES_ARRAY_NOBAM=()
    I=1
    for BAM in "${SUBREADS_FILES_ARRAY_BAM[@]}"; do
        if [[ "$BAM" =~ (.*).bam ]]; then
            NOBAM=${BASH_REMATCH[1]}
            SUBREADS_FILES_ARRAY_NOBAM[ $I ]="$NOBAM"
        fi
        (( I++ ))
    done

    SCRAPS_FILES_ARRAY_NOBAM=()
    I=1
    for BAM in "${SCRAPS_FILES_ARRAY_BAM[@]}"; do
        if [[ "$BAM" =~ (.*).bam ]]; then
            NOBAM=${BASH_REMATCH[1]}
            SCRAPS_FILES_ARRAY_NOBAM[ $I ]="$NOBAM"
        fi
        (( I++ ))
    done


    #Make an array of base filenames (before .scraps or .subreads)
    FILES_BASE_ARRAY=()
    I=1
    for NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
        if [[ "$NOBAM" =~ (.*).subreads ]]; then
            BASE=${BASH_REMATCH[1]}
            FILES_BASE_ARRAY[ $I ]="$BASE"
        fi
        (( I++ ))
    done

    FILES_BASE_ARRAY2=()
    I=1
    for NOBAM in "${SCRAPS_FILES_ARRAY_NOBAM[@]}"; do
        if [[ "$NOBAM" =~ (.*).scraps ]]; then
            BASE=${BASH_REMATCH[1]}
            FILES_BASE_ARRAY2[ $I ]="$BASE"
        fi
        (( I++ ))
    done


    #Ensure that the scraps and subreads files match
    if [ "${FILES_BASE_ARRAY[*]}" != "${FILES_BASE_ARRAY2[*]}" ]; then
        echo -e "\nERROR: Your scraps and subreads files do not match"
        print_help_menu
    fi


    #Convert BAM files to SAM files
    FAILED_EXTRACTION="ERROR: BAM to SAM data conversion failed!"
    if [ $VERBOSE == true ]; then
        echo "Beginning to convert data from BAM to SAM format"
    fi

    I=1
    for BAM in "${SUBREADS_FILES_ARRAY_BAM[@]}"; do
        #Check that .bam files exist and are not empty
        if [ ! -s "$BAM" ]; then
            echo >&2 "the BAM file "$BAM" is empty or does not exist"
            print_help_menu
        fi

        #Convert BAM files to SAM format
        SUBREADS_NOBAM=${SUBREADS_FILES_ARRAY_NOBAM[I]}
        samtools view --threads "$NTHREADS" -O SAM -h "$BAM" > "$SUBREADS_NOBAM.sam" || {
        echo >&2 "$FAILED_EXTRACTION"
        exit 1
        }

        SCRAPS_NOBAM=${SCRAPS_FILES_ARRAY_NOBAM[I]}
        samtools view --threads "$NTHREADS" -O SAM -h "$SCRAPS_NOBAM.bam" > "$SCRAPS_NOBAM.sam" || {
        echo >&2 "$FAILED_EXTRACTION"
        exit 1
        }

        (( I++ ))
    done

    if [ $VERBOSE == true ]; then
        echo "BAM to SAM data conversion was sucessful!"
        echo "Beginning to filter reads by chosen criteria"
    fi


    #Use SAM files to filter by chosen criteria
    I=1
    for SUBREADS_NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
        SCRAPS_NOBAM=${SCRAPS_FILES_ARRAY_NOBAM[I]}
        python filterReads.py "$SUBREADS_NOBAM.sam" "$SCRAPS_NOBAM.sam" "$OUT_FOLD" "$CLR_FILT" "$NUMPASS_FILT" "$NORMSCRAP_FILT" "$CLR_FILT_THRESH" || {
        echo >&2 "ERROR: Read filtering failed!"
        exit 1
        }

        (( I++ ))
    done


    if [ $FORMAT == 'b' ] || [ $FORMAT == "2"  ]; then
        #If the user has requested it, convert the filtered files to BAM format
        if [ $VERBOSE == true ]; then
            echo "Beginning to convert filtered data files to BAM format"
        fi

        I=1
        for NOBAM in "${SUBREADS_FILES_ARRAY_NOBAM[@]}"; do
            if [[ "$NOBAM" =~ (.*).subreads ]]; then
                BASE=${BASH_REMATCH[1]}
                FILES_BASE_ARRAY[ $I ]="$BASE"
            fi

            #Convert BAM files to SAM format
            samtools view --threads "$NTHREADS" -O BAM -h "$OUT_FOLD/$BASE.subreads.filt.sam" > "$OUT_FOLD/$BASE.subreads.filt.bam" || {
            echo >&2 "ERROR: SAM to BAM conversion of filtered subreads files failed!"
            exit 1
            }

            if [ $NOSCRAPS == false ]; then
                samtools view --threads "$NTHREADS" -O BAM -h "$OUT_FOLD/$BASE.scraps.filt.sam" > "$OUT_FOLD/$BASE.scraps.filt.bam" || {
                echo >&2 "ERROR: SAM to BAM conversion of filtered scraps files failed!"
                exit 1
                }
            fi


            if [ $FORMAT != "2" ]; then
		if [ $VERBOSE == true ]; then
                    echo "Beginning to delete SAM format filtered subreads files"
	        fi
                rm "$OUT_FOLD/$BASE.subreads.filt.sam" || {
                echo >&2 "ERROR: SAM format filtered subreads file deletion failed!"
                exit 1
                }

                if [ $NOSCRAPS == false ]; then
		    if [ $VERBOSE == true ]; then
                        echo "Beginning to delete SAM format filtered scraps files"
	            fi
                    rm "$OUT_FOLD/$BASE.scraps.filt.sam" || {
                    echo >&2 "ERROR: SAM format filtered scraps file deletion failed!"
                    exit 1
                    }
                fi
            fi

            (( I++ ))
        done

        if [ $VERBOSE == true ]; then
            echo "SAM to BAM conversion of filtered read data files is complete!"
        fi
    fi
fi


#Tell the user that SequelTools has finished
echo -e "SequelTools has finished!\n"




